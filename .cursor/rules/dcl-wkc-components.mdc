---
description: Decentraland Well-Known Components (WKC) architecture patterns and conventions.
globs: src/components.ts,test/components.ts,src/types/components.ts,src/types/system.ts,src/logic/*/component.ts,src/adapters/*.ts,src/adapters/**/*.ts,src/controllers/handlers/**/*.ts,docs/openapi.yaml
alwaysApply: false
---

# Decentraland Well-Known Components (WKC)

## Scope

- `src/components.ts` - Main component initialization file
- `test/components.ts` - Test environment component setup
- `src/types/components.ts` - Component interface definitions
- `src/types/system.ts` - System-wide type definitions
- `src/logic/*/component.ts` - Individual component implementations (job, ws-pool)
- `src/adapters/*.ts` - External service integration components
- `src/adapters/**/*.ts` - Adapter subdirectories (like rpc-server/)
- `src/controllers/handlers/**/*.ts` - HTTP/RPC/UWS handler components
- `docs/openapi.yaml` - OpenAPI 3.x.x specification for HTTP endpoints

## Rules

### 1. Component Interface Design

**MUST** (required)

- All components must extend `IBaseComponent` from `@well-known-components/interfaces`
- Component interfaces must be defined in `types/components.ts`
- Use TypeScript interfaces with minimal, focused responsibilities
- Implement lifecycle symbols `START_COMPONENT` and `STOP_COMPONENT` when needed

```typescript
// ❌ Incorrect
export interface IUserComponent {
  getUser: (id: string) => User
  createUser: (data: any) => User
  updateUser: (id: string, data: any) => User
  deleteUser: (id: string) => void
  sendEmail: (to: string, content: string) => void // Mixed responsibilities
}

// ✅ Correct
export interface IUserComponent extends IBaseComponent {
  getUser: (id: string) => Promise<User>
  createUser: (data: CreateUserData) => Promise<User>
  updateUser: (id: string, data: UpdateUserData) => Promise<User>
  deleteUser: (id: string) => Promise<void>
}
```

### 2. Component Factory Pattern

**MUST** (required)

- Use async factory functions with `create*Component` naming convention
- Accept dependencies through `Pick<AppComponents, 'dependency1' | 'dependency2'>` parameter
- Return objects implementing the component interface
- Handle component initialization and dependency injection properly

```typescript
// ❌ Incorrect
export function createUserComponent(db: any, logger: any): IUserComponent {
  return {
    getUser: (id) => db.query('SELECT * FROM users WHERE id = ?', [id])
  }
}

// ✅ Correct
/**
 * Creates the User component
 *
 * Orchestrates user management operations:
 * 1. Validates user data and permissions
 * 2. Interacts with database for CRUD operations
 * 3. Logs all user-related activities
 *
 * @param components Required components: database, logger
 * @returns IUserComponent implementation
 */
export async function createUserComponent(
  components: Pick<AppComponents, 'database' | 'logger'>
): Promise<IUserComponent> {
  const { database, logger } = components

  return {
    /**
     * Retrieves a user by their unique identifier
     *
     * @param id - The unique identifier of the user
     * @returns The user object if found
     * @throws {UserNotFoundError} If the user with the given id does not exist
     */
    async getUser(id: string): Promise<User> {
      logger.info('Fetching user', { userId: id })
      return await database.query('SELECT * FROM users WHERE id = $1', [id])
    }
  }
}
```

### 3. Component Lifecycle Management

**MUST** (required)

- Implement `START_COMPONENT` and `STOP_COMPONENT` symbols for stateful components
- Use proper async initialization patterns
- Handle cleanup and resource disposal in stop functions
- Ensure graceful shutdown capabilities

```typescript
// ❌ Incorrect
export async function createJobComponent(components: Pick<AppComponents, 'config'>): Promise<IJobComponent> {
  const jobs = setInterval(() => {
    // Job logic
  }, 5000)

  return {
    scheduleJob: (job) => {
      /* implementation */
    }
  }
}

// ✅ Correct
export async function createJobComponent(components: Pick<AppComponents, 'config'>): Promise<IJobComponent> {
  const { config } = components
  let intervalId: NodeJS.Timer | undefined

  const start = async () => {
    intervalId = setInterval(() => {
      // Job logic
    }, config.getNumber('JOB_INTERVAL', 5000))
  }

  const stop = async () => {
    if (intervalId) {
      clearInterval(intervalId)
      intervalId = undefined
    }
  }

  return {
    [START_COMPONENT]: start,
    [STOP_COMPONENT]: stop,
    scheduleJob: (job) => {
      /* implementation */
    }
  }
}
```

### 4. Component Organization

**MUST** (required)

- Follow the WKC architecture pattern with clear separation of concerns
- Organize components by their responsibilities in the appropriate directories

**Directory Structure:**

- **`src/adapters/`** - External service integrations (databases, APIs, third-party services)

  - PostgreSQL, Redis, S3, SNS, Catalyst clients
  - Email services, CDN cache invalidation
  - Any component that communicates with external systems

- **`src/logic/`** - Business logic components (domain-specific functionality)

  - User management, communities, friendships
  - Job scheduling, notifications, voice chat
  - Any component that implements business rules

- **`src/controllers/`** - Request/response handling (presentation layer)

  - HTTP handlers, RPC handlers, WebSocket handlers
  - Route definitions, middleware
  - Input validation and response formatting

- **`src/types/`** - Shared type definitions
  - Component interfaces in `components.ts`
  - System-wide types in `system.ts`
  - Handler-specific types

**Component File Organization:**

- Place component interfaces in `types/components.ts` or `logic/component/types.ts`
- Use `components.ts` for main component initialization and dependency wiring
- Create `logic/component/component.ts` (with index.ts) or `logic/component.ts` for component implementation
- Include `logic/component/index.ts` to export the component and types

```typescript
// ❌ Incorrect - Mixed concerns in single file
// src/userStuff.ts
export interface IUserComponent {
  /* ... */
}
export interface IEmailComponent {
  /* ... */
}
export async function createUserComponent() {
  /* ... */
}
export async function createEmailComponent() {
  /* ... */
}

// ✅ Correct - Separated concerns
// src/types/components.ts
export interface IUserComponent extends IBaseComponent {
  /* ... */
}
export interface IEmailComponent extends IBaseComponent {
  /* ... */
}

// src/logic/user/user.ts
export async function createUserComponent() {
  /* ... */
}

// src/logic/user/index.ts
export { createUserComponent } from './user'

// src/adapters/email.ts
export async function createEmailComponent() {
  /* ... */
}
```

### 5. Dependency Injection

**MUST** (required)

- Use `Pick<AppComponents, 'dependency1' | 'dependency2'>` for explicit dependency declaration
- Destructure dependencies at the beginning of factory functions
- Avoid circular dependencies between components
- Pass only necessary dependencies to each component

```typescript
// ❌ Incorrect
export async function createUserComponent(components: AppComponents): Promise<IUserComponent> {
  // Uses all components, unclear dependencies
  return {
    getUser: (id) => components.database.query(/* ... */)
  }
}

// ✅ Correct
/**
 * Creates the User component
 *
 * Orchestrates user management operations with proper dependency injection:
 * 1. Validates user data and permissions
 * 2. Interacts with database for CRUD operations
 * 3. Logs all user-related activities
 * 4. Tracks performance metrics for user operations
 *
 * @param components Required components: database, logs, metrics
 * @returns IUserComponent implementation
 */
export async function createUserComponent(
  components: Pick<AppComponents, 'database' | 'logs' | 'metrics'>
): Promise<IUserComponent> {
  const { database, logs, metrics } = components
  const logger = logs.getLogger('user-component')

  return {
    /**
     * Retrieves a user by their unique identifier
     *
     * @param id - The unique identifier of the user
     * @returns The user object if found
     * @throws {UserNotFoundError} If the user with the given id does not exist
     */
    async getUser(id: string): Promise<User> {
      const timer = metrics.startTimer('user_get_duration')
      try {
        logger.debug('Fetching user', { userId: id })
        const user = await database.query('SELECT * FROM users WHERE id = $1', [id])
        return user
      } finally {
        timer()
      }
    }
  }
}
```

### 6. Error Handling

**SHOULD** (recommended)

- Use typed error classes for domain-specific errors
- Implement proper error logging and tracing
- Handle component initialization failures gracefully
- Provide meaningful error messages

```typescript
// ❌ Incorrect
export async function createUserComponent(components: Pick<AppComponents, 'database'>): Promise<IUserComponent> {
  return {
    async getUser(id: string): Promise<User> {
      const user = await components.database.query('SELECT * FROM users WHERE id = $1', [id])
      if (!user) {
        throw new Error('User not found')
      }
      return user
    }
  }
}

// ✅ Correct
/**
 * Creates the User component
 *
 * Orchestrates user management operations with proper error handling:
 * 1. Validates user data and permissions
 * 2. Interacts with database for CRUD operations
 * 3. Logs all user-related activities and errors
 *
 * @param components Required components: database, logs
 * @returns IUserComponent implementation
 */
export async function createUserComponent(
  components: Pick<AppComponents, 'database' | 'logs'>
): Promise<IUserComponent> {
  const { database, logs } = components
  const logger = logs.getLogger('user-component')

  return {
    /**
     * Retrieves a user by their unique identifier
     *
     * This method MUST validate the user exists before returning.
     * All errors are logged for debugging and audit purposes.
     *
     * @param id - The unique identifier of the user
     * @returns The user object if found
     * @throws {UserNotFoundError} If the user with the given id does not exist
     * @throws {DatabaseError} If a database error occurs during the query
     */
    async getUser(id: string): Promise<User> {
      try {
        const user = await database.query('SELECT * FROM users WHERE id = $1', [id])
        if (!user) {
          throw new UserNotFoundError(`User with id ${id} not found`)
        }
        return user
      } catch (error) {
        logger.error('Error fetching user', { userId: id, error })
        throw error
      }
    }
  }
}
```

### 7. JSDoc Documentation

**MUST** (required)

- Document all component factory functions with comprehensive JSDoc comments
- Document all public methods in component interfaces with JSDoc
- Use standard JSDoc tags (`@param`, `@returns`, `@throws`) for type information
- Include descriptive comments that explain purpose, behavior, and important constraints
- Document dependencies clearly in factory function comments
- Follow JSDoc syntax that is compatible with TypeScript and automated documentation generation

**JSDoc Tags:**

- `@param` - Document function parameters with type and description
- `@returns` - Document return type and value description
- `@throws` - Document exceptions that may be thrown, with error types
- `@description` - Multi-line description (optional, can use free-form text)

**Documentation Standards:**

- Factory functions must document the orchestration flow and component purpose
- Method documentation must explain behavior, preconditions, and side effects
- Error conditions must be explicitly documented with `@throws` tags
- Complex logic flows should be documented with numbered steps or bullet points
- Dependencies should be documented in factory function comments listing required components

```typescript
// ❌ Incorrect - Missing documentation
export async function createUserComponent(
  components: Pick<AppComponents, 'database' | 'logs'>
): Promise<IUserComponent> {
  const { database, logs } = components

  return {
    async getUser(id: string): Promise<User> {
      const user = await database.query('SELECT * FROM users WHERE id = $1', [id])
      if (!user) {
        throw new UserNotFoundError(`User with id ${id} not found`)
      }
      return user
    }
  }
}

// ✅ Correct - Comprehensive JSDoc documentation
/**
 * Creates the User component
 *
 * Orchestrates user management operations:
 * 1. Validates user data and permissions
 * 2. Interacts with database for CRUD operations
 * 3. Logs all user-related activities
 *
 * @param components Required components: database, logs
 * @returns IUserComponent implementation
 */
export async function createUserComponent(
  components: Pick<AppComponents, 'database' | 'logs'>
): Promise<IUserComponent> {
  const { database, logs } = components
  const logger = logs.getLogger('user-component')

  return {
    /**
     * Retrieves a user by their unique identifier
     *
     * This method MUST validate the user exists before returning.
     * All database queries are logged for audit purposes.
     *
     * @param id - The unique identifier of the user
     * @returns The user object if found
     * @throws {UserNotFoundError} If the user with the given id does not exist
     */
    async getUser(id: string): Promise<User> {
      logger.debug('Fetching user', { userId: id })
      const user = await database.query('SELECT * FROM users WHERE id = $1', [id])
      if (!user) {
        throw new UserNotFoundError(`User with id ${id} not found`)
      }
      return user
    }
  }
}
```

**Documentation for Complex Methods:**

```typescript
// ✅ Correct - Detailed method documentation with flow description
/**
 * Validates operation parameters and prepares result metadata
 *
 * This method MUST be called before executing the operation to ensure
 * all validations pass before committing to a specific response status.
 *
 * The validation process follows these steps:
 * 1. Validates input format and required fields
 * 2. Checks authorization and permissions
 * 3. Verifies resource existence and state
 * 4. Prepares response metadata structure
 *
 * @param params - Operation parameters containing identifier and options
 * @returns Prepared metadata object with validation results
 * @throws {ValidationError} If input parameters are invalid or malformed
 * @throws {UnauthorizedError} If user lacks required permissions
 * @throws {NotFoundError} If the referenced resource does not exist
 */
async function prepareOperation(params: OperationParams): Promise<OperationMetadata> {
  // Implementation
}
```

**Documentation for Interface Methods:**

```typescript
// ✅ Correct - Interface methods should also be documented
/**
 * User management component interface
 */
export interface IUserComponent extends IBaseComponent {
  /**
   * Retrieves a user by their unique identifier
   *
   * @param id - The unique identifier of the user
   * @returns Promise resolving to the user object
   * @throws {UserNotFoundError} If the user does not exist
   */
  getUser: (id: string) => Promise<User>

  /**
   * Creates a new user with the provided data
   *
   * @param data - User creation data including email and name
   * @returns Promise resolving to the created user object
   * @throws {ValidationError} If user data is invalid
   * @throws {DuplicateUserError} If a user with the same email already exists
   */
  createUser: (data: CreateUserData) => Promise<User>
}
```

### 8. OpenAPI Documentation

**MUST** (required)

- Create `docs/` directory and `docs/openapi.yaml` file if they don't exist
- Document all HTTP endpoints using OpenAPI 3.x.x standard
- Include comprehensive request/response schemas
- Document error responses with proper status codes

**Directory Structure:**

- **`docs/`** - API documentation directory
  - `openapi.yaml` - Main OpenAPI specification file

**Documentation Maintenance:**

- Update `docs/openapi.yaml` whenever adding, modifying, or removing endpoints
- Include all HTTP status codes that the endpoint can return
- Use consistent error response formats across all endpoints
- Document authentication requirements if applicable
- Include rate limiting information if implemented

## Examples

### Complete Component Implementation

```typescript
// types/components.ts
/**
 * User management component interface
 */
export interface IUserComponent extends IBaseComponent {
  /**
   * Retrieves a user by their unique identifier
   *
   * @param id - The unique identifier of the user
   * @returns Promise resolving to the user object
   * @throws {UserNotFoundError} If the user does not exist
   */
  getUser: (id: string) => Promise<User>

  /**
   * Creates a new user with the provided data
   *
   * @param data - User creation data including email and name
   * @returns Promise resolving to the created user object
   * @throws {ValidationError} If user data is invalid
   * @throws {DuplicateUserError} If a user with the same email already exists
   */
  createUser: (data: CreateUserData) => Promise<User>

  /**
   * Updates an existing user with new data
   *
   * @param id - The unique identifier of the user to update
   * @param data - User update data containing fields to modify
   * @returns Promise resolving to the updated user object
   * @throws {UserNotFoundError} If the user does not exist
   * @throws {ValidationError} If update data is invalid
   */
  updateUser: (id: string, data: UpdateUserData) => Promise<User>

  /**
   * Deletes a user by their unique identifier
   *
   * @param id - The unique identifier of the user to delete
   * @returns Promise resolving when deletion is complete
   * @throws {UserNotFoundError} If the user does not exist
   */
  deleteUser: (id: string) => Promise<void>
}

// src/logic/user/user.ts
import { IBaseComponent, START_COMPONENT, STOP_COMPONENT } from '@well-known-components/interfaces'
import { IUserComponent } from './types'
import { UserNotFoundError } from './errors'

/**
 * Creates the User component
 *
 * Orchestrates user management operations:
 * 1. Validates user data and permissions
 * 2. Interacts with database for CRUD operations
 * 3. Logs all user-related activities
 * 4. Tracks performance metrics for user operations
 *
 * @param components Required components: database, logs, metrics
 * @returns IUserComponent implementation
 */
export async function createUserComponent(
  components: Pick<AppComponents, 'database' | 'logs' | 'metrics'>
): Promise<IUserComponent> {
  const { database, logs, metrics } = components
  const logger = logs.getLogger('user-component')

  return {
    /**
     * Retrieves a user by their unique identifier
     *
     * This method MUST validate the user exists before returning.
     * All database queries are logged for audit purposes and tracked with metrics.
     *
     * @param id - The unique identifier of the user
     * @returns The user object if found
     * @throws {UserNotFoundError} If the user with the given id does not exist
     */
    async getUser(id: string): Promise<User> {
      const timer = metrics.startTimer('user_get_duration')
      try {
        logger.debug('Fetching user', { userId: id })
        const user = await database.query('SELECT * FROM users WHERE id = $1', [id])
        if (!user) {
          throw new UserNotFoundError(`User with id ${id} not found`)
        }
        return user
      } finally {
        timer()
      }
    },

    /**
     * Creates a new user with the provided data
     *
     * This method validates the input data and inserts a new user record.
     * The operation is logged and tracked with metrics.
     *
     * @param data - User creation data including email and name
     * @returns The created user object
     * @throws {ValidationError} If user data is invalid
     * @throws {DuplicateUserError} If a user with the same email already exists
     */
    async createUser(data: CreateUserData): Promise<User> {
      logger.info('Creating user', { email: data.email })
      const user = await database.query('INSERT INTO users (email, name) VALUES ($1, $2) RETURNING *', [
        data.email,
        data.name
      ])
      return user
    },

    /**
     * Updates an existing user with new data
     *
     * This method MUST validate the user exists before updating.
     * All updates are logged for audit purposes.
     *
     * @param id - The unique identifier of the user to update
     * @param data - User update data containing fields to modify
     * @returns The updated user object
     * @throws {UserNotFoundError} If the user with the given id does not exist
     * @throws {ValidationError} If update data is invalid
     */
    async updateUser(id: string, data: UpdateUserData): Promise<User> {
      logger.info('Updating user', { userId: id })
      const user = await database.query('UPDATE users SET name = $1 WHERE id = $2 RETURNING *', [data.name, id])
      if (!user) {
        throw new UserNotFoundError(`User with id ${id} not found`)
      }
      return user
    },

    /**
     * Deletes a user by their unique identifier
     *
     * This method permanently removes the user from the database.
     * The deletion is logged for audit purposes.
     *
     * @param id - The unique identifier of the user to delete
     * @throws {UserNotFoundError} If the user with the given id does not exist
     */
    async deleteUser(id: string): Promise<void> {
      logger.info('Deleting user', { userId: id })
      await database.query('DELETE FROM users WHERE id = $1', [id])
    }
  }
}

// src/logic/user/index.ts
export { createUserComponent } from './user'
export type { IUserComponent } from './types'
```

## Validation Checklist

Before submitting a WKC component, ensure each rule has clear MUST and SHOULD sections with specific code examples showing both incorrect (❌) and correct (✅) patterns. Rules must be specific and actionable while scope clearly defines file patterns. Description is concise and descriptive with glob patterns are appropriate for the established format and structure. Content is comprehensive and well-organized with examples relevant and demonstrate best practices. Rules are independent and don't share state, prefer specific outcomes over generic ones. Context is properly defined and not repeated with each section has appropriate setup and cleanup:

- [ ] Component extends `IBaseComponent` interface
- [ ] Factory function follows `create*Component` naming convention
- [ ] Dependencies are explicitly declared using `Pick<AppComponents, ...>`
- [ ] Component implements proper async patterns
- [ ] Error handling includes logging and typed errors
- [ ] Lifecycle methods (`START_COMPONENT`, `STOP_COMPONENT`) are implemented when needed
- [ ] Component is organized in appropriate directory (`adapters/` or `logic/`)
- [ ] Interface is defined in `types/components.ts`
- [ ] Component has focused, single responsibility
- [ ] Dependencies are minimal and non-circular
- [ ] Resource cleanup is handled in stop methods
- [ ] Metrics and logging are properly integrated
- [ ] TypeScript types are comprehensive and accurate
- [ ] Component follows WKC philosophy of decoupling business logic from technology decisions
- [ ] Factory function has comprehensive JSDoc documentation with description, orchestration flow, and dependency listing
- [ ] All public component methods have JSDoc documentation with `@param`, `@returns`, and `@throws` tags
- [ ] Interface methods have JSDoc documentation for consistency and IDE support
- [ ] Error conditions are explicitly documented with `@throws` tags including error types
- [ ] Complex logic flows are documented with numbered steps or bullet points
- [ ] JSDoc comments are compatible with TypeScript and automated documentation generation
- [ ] HTTP endpoints are documented in `docs/openapi.yaml` with comprehensive schemas, status codes, and consistent error formats
- [ ] Documentation is updated whenever endpoints are added, modified, or removed

**Purpose**: This checklist ensures that all WKC components follow Decentraland's established patterns for dependency injection, lifecycle management, and clean architecture principles while maintaining maintainability.
